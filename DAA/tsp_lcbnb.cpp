#include <iostream>
#include <bits/stdc++.h>
using namespace std;
using namespace std::chrono;

// every parent child branch will have a unique name
// child is generated by working on the parent vector hence its called worked upon
// vector that child uses for its future children is called modified with respect to the child
// x,y of child will trace the edge wt of parent-child edge in worked upon vector
//  we have a hashmap that stores branchname to node , every node has a unique branch name

// current branch name=parent node branch name +i
// genesis node has branch name 0 cause it has no parent
// children of genesis node are first level of children thus they have branch name as 00,01,02,03 and so on

class Node
{
public:
    // child details
};

void print1d(vector<int> v)
{
    cout << " 1D VECTOR " << endl;
    for (int i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }
    cout << endl;
    cout << endl;
}

void print2d(vector<vector<int>> v)
{
    cout << " 2D VECTOR " << endl;
    for (int i = 0; i < v.size(); i++)
    {
        for (int j = 0; j < v[i].size(); j++)
        {
            if (v[i][j] < 10 and v[i][j] >= 0)
            {
                cout << "0";
            }
            cout << v[i][j] << " ";
        }
        cout << endl;
    }
    cout << endl;
    cout << endl;
}

void reduce(int &cost, vector<vector<int>> &parent)
{
    int n = parent.size();
    for (int i = 0; i < n; i++)
    {

        int m = INT_MAX;
        for (int j = 0; j < n; j++)
        {
            if (parent[i][j] != -1)
            {
                m = min(m, parent[i][j]);
            }
        }
        // if all are -1 m will remain int max only
        if (m != 0 and m != INT_MAX)
        {
            for (int j = 0; j < n; j++)
            {
                if (parent[i][j] != -1)
                {
                    parent[i][j] = parent[i][j] - m;
                }
            }
            cost += m;
        }
    }
    // print2d(parent);
    //  column reduction
    for (int j = 0; j < n; j++)
    {

        int m = INT_MAX;
        for (int i = 0; i < n; i++)
        {
            if (parent[i][j] != -1)
            {
                m = min(m, parent[i][j]);
            }
        }
        if (m != 0 and m != INT_MAX)
        {
            for (int i = 0; i < n; i++)
            {
                if (parent[i][j] != -1)
                {
                    parent[i][j] = parent[i][j] - m;
                }
            }
            cost += m;
        }
    }
    cout << "Reduction cost: " << cost << endl;
}

int tsp(int upperBound,int parent_index,int child_index,int parent_cost){
    //edge at any instance is worked-upon[parent_index][child_index]

    
}

void mymain(vector<vector<int>> &v)
{
    // a tsp is like an mst but just 1 difference , the lost node again connects to start position thereby making it a cycle and wo path ka bhi cost is considered
    int cost=0;
    reduce(cost,v);
    vector<vector<int>> worked_upon=v;
    print2d(worked_upon);
    // every node appears in final answer hence we can choose any start point for our tsp let that be 0th index
}

int main()
{
    // take all input here
    vector<vector<int>> v = { {-1, 20, 30, 10},
                              {15, -1, 16, 4},
                              {3, 5, -1, 2},
                              {19, 6, 18, -1} };
    // input end
    chrono::system_clock::time_point start = high_resolution_clock::now();
    mymain(v);
    chrono::system_clock::time_point stop = high_resolution_clock::now();
    chrono::milliseconds duration = duration_cast<milliseconds>(stop - start);

    double time = duration.count();
    string unit = "ms";
    if (time >= 1000 and time < 60000)
    {
        time = time / 1000;
        unit = "sec";
    }
    cout << endl;
    cout << endl;
    cout << "Code Execution Time: " << time << " " << unit << endl;
    return 0;
}